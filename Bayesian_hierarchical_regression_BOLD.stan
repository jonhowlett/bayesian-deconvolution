functions{

  // convolution function

  vector stan_convolve(int nPoints, vector a,  vector b) {
  
    vector [nPoints] out;

    int indices[nPoints];

    for(i in 1:nPoints){
      indices[i]=i;
    }
  
    for(i in 1:nPoints){
      out[i] = dot_product(a[1:i], b[sort_desc(indices[1:i])]);

    }
 
    return(out);

  }  

  vector repeat_vector(vector input, int K) {
    int N = rows(input);
    vector[N*K] repvec; // stack N-vector K times

    for (k in 1:K) {
      for (i in 1:N) {
        repvec[i+(k-1)*N] = input[i]; // assign i-th value of input to i+(k-1)*N -th value of repvec
      }
    }
    return repvec;
  }

}
data {

  int<lower=1> N; // Number of participants
  int<lower=1> T; // Number of trials
  int<lower=1> TR; // Number of TR timepoints
  int<lower=1> nreg; // Number of regressors

  matrix[T+1, nreg] regs; // Matrix of regressors where columns are regressors and rows are 
                          // trials; a first row of all 0s must be appended
 
  vector[N*TR] B; // BOLD signal at each TR timepoint (concatenated into a vector)

  int censlength; // Total number of uncensored volumes across all participants

  int cens[censlength]; // Indices of uncensored volumes (indices are counted in terms of vector of length N*TR)

  vector[TR] HRF; // Vector representing HRF

  int trial1[TR]; // This is generated by first setting the specific timepoints to be convolved with the HRF 
                  // to be the trial number associated with the event, and all other timepoints to be zero,
                  // e.g. c(1, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3 ...), and then adding 1 to every entry,
                  // e.g. c(2, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 1, 4 ...). 
                  // The purpose is to enable translation between the trial and TR levels

}
transformed data{

  matrix[N*TR, nreg] tr_reg;

  for(i in 1:nreg){

    tr_reg[,i] = repeat_vector(stan_convolve(TR, regs[trial1, i], HRF),N); // We first convolve the regressors with the HRF

  }
 

}
parameters {

  vector[nreg] mu_beta; // group mean of individual slopes

  matrix[nreg, N] beta; // individual slopes for each regressor

  vector<lower=0>[N] intercept; // individual intercept term for BOLD signal regression

  vector<lower=0>[N] sigma; // standard deviation for BOLD signal regression

  vector<lower=0>[nreg] sigma_beta; // standard deviation for group distribution of slopes


}
model {

  vector[N*TR] sigma_vect;

  vector[N*TR] x;

  mu_beta ~ normal(0, 10);

  intercept ~ normal(0, 10);

  sigma ~ normal(0, 5);


  for(i in 1:nreg){

    beta[i,] ~ normal(mu_beta[i], sigma_beta[i]);

  }

  for(n in 1:N){

    sigma_vect[((n-1)*TR+1):(n*TR)]=rep_vector(sigma[n],TR);

    x[((n-1)*TR+1):(n*TR)]=rep_vector(intercept[n],TR);

    for(i in 1:nreg){

      x[((n-1)*TR+1):(n*TR)]=x[((n-1)*TR+1):(n*TR)] + beta[i,n] * tr_reg[((n-1)*TR+1):(n*TR),i]; // we concatenate regressors as this makes it easier to handle censored volumes

   }

    
  }

  B[cens] ~ normal(x[cens], sigma_vect[cens]); // BOLD signal regression

}
